/*
 * Copyright 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package com.google.gwt.inject.rebind;

import com.google.gwt.core.ext.GeneratorContext;
import com.google.gwt.core.ext.TreeLogger;
import com.google.gwt.dev.javac.CompilationState;
import com.google.gwt.dev.javac.CompiledClass;
import com.google.gwt.dev.javac.StandardGeneratorContext;

import java.lang.reflect.Field;
import java.util.Map;

/**
 * Gin-internal class loader that allows us to load classes generated by other generators. This
 * class loader usually defers to its parent (i.e. the system class loader) and so any class that
 * can be retrieved in that manner will not be loaded through it. For classes that are not available
 * to the system, this class loader attempts to find them in GWT's compilation state.
 *
 * <p>Unfortunately, GWT does not like to expose internal details like the compilation state and its
 * bytes. For now, we use reflection to access this internal state but in the long term we should
 * switch to other strategies such as running javac on source (which we'd need to reverse-engineer
 * from parsing the GWT AST).
 */
class GinBridgeClassLoader extends ClassLoader {

  private final TreeLogger logger;
  private final GeneratorContext context;

  // Lazily load class files from compilation state.
  private boolean loadedClassFiles = false;
  private Map<String, CompiledClass> classFileMap;

  GinBridgeClassLoader(GeneratorContext context, TreeLogger logger) {
    super(); // Use regular class loader before falling back to this one.
    this.context = context;
    this.logger = logger;
  }

  /**
   * Looks up classes in GWT's compilation state.
   */
  @Override
  protected Class<?> findClass(String name) throws ClassNotFoundException {
    if (!loadedClassFiles) {
      classFileMap = extractClassFileMap();
      loadedClassFiles = true;
    }

    if (classFileMap == null) {
      throw new ClassNotFoundException(name);
    }

    String internalName = name.replace('.', '/');
    CompiledClass compiledClass = classFileMap.get(internalName);
    if (compiledClass == null) {
      throw new ClassNotFoundException(name);
    }
    byte[] bytes = compiledClass.getBytes();
    return defineClass(name, bytes, 0, bytes.length);
  }

  /**
   * Retrieves class definitions from a {@link GeneratorContext} by means of reflection.
   */
  private Map<String, CompiledClass> extractClassFileMap() {
    if (context instanceof StandardGeneratorContext) {
      StandardGeneratorContext standardContext = (StandardGeneratorContext) context;

      try {
        CompilationState compilationState =
            getFieldValue(StandardGeneratorContext.class, standardContext, "compilationState");
        return getFieldValue(CompilationState.class, compilationState, "exposedClassFileMap");
      } catch (FieldLoadException e) {
        logger.log(TreeLogger.Type.WARN,
            String.format(
                "Could not load generated classes from GWT context, failed to access %s#%s",
                e.declaringType, e.fieldName),
            e.getCause());
        return null;
      }
    } else {
      logger.log(TreeLogger.Type.WARN,
          String.format("Could not load generated classes from GWT context, "
              + "encountered unexpected generator type %s.", context.getClass()));
      return null;
    }
  }

  private <S, T extends S, F> F getFieldValue(Class<S> declaringType, T owner, String fieldName)
      throws FieldLoadException {
    Field field;
    try {
      field = declaringType.getDeclaredField(fieldName);
    } catch (NoSuchFieldException e) {
      throw new FieldLoadException(e, fieldName, declaringType);
    }

    boolean accessible = field.isAccessible();
    field.setAccessible(true);
    try {
      @SuppressWarnings("unchecked") // Reflection field values are untyped.
      F value = (F) field.get(owner);
      return value;
    } catch (IllegalAccessException e) {
      throw new FieldLoadException(e, fieldName, declaringType);
    } catch (ClassCastException e) {
      throw new FieldLoadException(e, fieldName, declaringType);
    } finally {
      field.setAccessible(accessible);
    }
  }

  private static class FieldLoadException extends Exception {
    private final String fieldName;
    private final Class<?> declaringType;

    private FieldLoadException(Throwable throwable, String fieldName, Class<?> declaringType) {
      super(throwable);
      this.fieldName = fieldName;
      this.declaringType = declaringType;
    }
  }
}
